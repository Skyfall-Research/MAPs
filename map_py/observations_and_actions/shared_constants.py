"""Helpful constants documenting the action and state spaces.
"""

import json
from pathlib import Path
import copy 
import yaml
import importlib.resources
import map_py

MODULE_PATH = importlib.resources.files(map_py).parent
# MAP Config
MAP_CONFIG_PATH = MODULE_PATH / 'shared' / 'config.yaml'
with open(MAP_CONFIG_PATH, 'r') as infile:
    MAP_CONFIG = yaml.safe_load(infile)

# Load shared action specification from JSON
def _load_action_spec(sandbox_action_spec: bool = False):
    # Get the path to the root directory (where action_spec.json is located)
    current_dir = Path(__file__).parent
    root_dir = current_dir.parent.parent  # Go up to project root
    file_name = 'sandbox_action_spec.json' if sandbox_action_spec else 'action_spec.json'
    action_spec_path = root_dir / 'shared' / file_name
    
    with open(action_spec_path, 'r') as f:
        return json.load(f)

# Load the shared specification
_action_spec_data = _load_action_spec()

# Generate ACTION_SPEC from shared data
ACTION_SPEC = _action_spec_data['actions']

# Generate actions by difficulty
ACTIONS_BY_DIFFICULTY = {
    'easy': ['place', 'move', 'remove', 'modify', 'survey_guests', 'wait'],
}
ACTIONS_BY_DIFFICULTY['medium'] = ACTIONS_BY_DIFFICULTY['easy'] + ['set_research']
ACTIONS_BY_DIFFICULTY['hard'] = ACTIONS_BY_DIFFICULTY['medium'] + ['add_path', 'remove_path', 'add_water', 'remove_water']
for actions in ACTIONS_BY_DIFFICULTY.values():
    assert all(action in [x['action_name'] for x in ACTION_SPEC] for action in actions)

# Generate ACTION_PARAMS from shared spec
ACTION_PARAMS = {}
for action in ACTION_SPEC:
    params = set(action['parameters'].keys())
    params.add('parkId')  # Always include parkId
    ACTION_PARAMS[action['action_name']] = params

# Generate ACTION_PARAM_TYPES from shared spec
_type_map = {
    'string': str,
    'number': int,
    'boolean': bool,
    'object': dict,
    'array': list
}

ACTION_PARAM_TYPES = {}
for param, type_name in _action_spec_data['param_types'].items():
    if type_name == 'array':
        ACTION_PARAM_TYPES[param] = list[str]  # Special case for research_topics
    else:
        ACTION_PARAM_TYPES[param] = _type_map.get(type_name, str)

_sandbox_action_spec_data = _load_action_spec(sandbox_action_spec=True)
SANDBOX_ACTION_SPEC = _sandbox_action_spec_data['sandbox_actions']
SANDBOX_ACTION_NAMES = [x['action_name'] for x in SANDBOX_ACTION_SPEC]
SANDBOX_ACTION_PARAMS = {}
for action in SANDBOX_ACTION_SPEC:
    params = set(action['parameters'].keys())
    params.add('parkId')  # Always include parkId
    SANDBOX_ACTION_PARAMS[action['action_name']] = params
SANDBOX_ACTION_PARAM_TYPES = {}
for param, type_name in _sandbox_action_spec_data['param_types'].items():
    if type_name == 'array':
        SANDBOX_ACTION_PARAM_TYPES[param] = list[str]  # Special case for research_topics
    else:
        SANDBOX_ACTION_PARAM_TYPES[param] = _type_map.get(type_name, str)

PARK_SIZE = MAP_CONFIG['park_size']

# Human-readable MAP Pydantic State Specification
STATE_SPEC_DICT = {
   "parkId": "The unique identifier for the park instance (String)",
   "step": "The current timestep of the game (Integer)",
   "horizon": "The maximum number of steps in the game (Integer)",
   "money": "The total amount of money in the bank (Integer)",
   "value": "The total value of the park including all assets (Integer)",
   "revenue": "The revenue generated by the park over the day (Integer)",
   "expenses": "The expenses incurred by the park over the day (Integer)",
   "profit": "The day's profit (revenue - expenses) (Integer)",
   "park_rating": "The park's rating from 0-100 (Float)",
   "research_speed": "Research speed setting: 'none', 'slow', 'medium', or 'fast' (String)",
   "research_topics": "Ride or shop type being researched in order (String): 'carousel', 'drink', 'ferris_wheel', 'food', 'janitor', 'mechanic', 'roller_coaster', 'specialist', or 'specialty'",
   "research_operating_cost": "Daily cost of the current research speed (Integer)",
   "new_entity_available": "Whether a new entity is now available for purchase thanks to research performed over the day (Boolean)",
   "available_entities": {
      "roller_coaster": ["Subclasses for roller coasters currently available (Strings)"],
      "ferris_wheel": ["Subclasses for ferris wheels currently available (Strings)"],
      "carousel": ["Subclasses for carousels currently available (Strings)"],
      "food": ["Subclasses for food shops currently available (Strings)"],
      "drink": ["Subclasses for drink shops currently available (Strings)"],
      "specialty": ["Subclasses for specialty shops currently available (Strings)"],
      "janitor": ["Subclasses for janitors currently available (Strings)"],
      "mechanic": ["Subclasses for mechanics currently available (Strings)"],
      "specialist": ["Subclasses for specialists currently available (Strings)"]
   },
   "fast_days_since_last_new_entity": "Number of days with fast research speed since the last new entity was added (Integer)",
   "medium_days_since_last_new_entity": "Number of days with medium research speed since the last new entity was added (Integer)",
   "slow_days_since_last_new_entity": "Number of days with slow research speed since the last new entity was added (Integer)",
   "entrance": "Coordinates of the park entrance as (x, y) tuple (Tuple[int, int])",
   "exit": "Coordinates of the park exit as (x, y) tuple (Tuple[int, int])",
   "min_cleanliness": "Minimum cleanliness of all tiles including paths and attractions (Float, 0.0 to 1.0)",
   "paths": "List of path tiles in the park (List[Path])",
   "waters": "List of water tiles in the park (List[Water])",
   "guests": {
      "total_guests": "The total number of guests in the park (Integer)",
      "avg_money_spent": "Average amount of money spent by guests (Float)",
      "avg_time_in_park": "Average amount of time a guest spends in the park (Float)",
      "avg_rides_visited": "Average number of rides visited by guests (Float)",
      "avg_food_shops_visited": "Average number of food shops visited by guests (Float)",
      "avg_drink_shops_visited": "Average number of drink shops visited by guests (Float)",
      "avg_specialty_shops_visited": "Average number of specialty shops visited by guests (Float)"
   },
   "guest_survey_results": {
      "age_of_results": "Age of the survey results in timesteps (Integer)",
      "list_of_results": "List of individual guest survey results (List[GuestSurveyResult])"
   },
   "rides": {
      "total_rides": "The total number of rides in the park (Integer)",
      "min_uptime": "Minimum uptime across all rides (Float, 0.0 to 1.0)",
      "total_operating_cost": "Sum of operating costs for all rides (Integer)",
      "total_revenue_generated": "Sum of revenue generated for all rides (Integer)",
      "total_excitement": "Aggregated excitement over all rides (Float)",
      "avg_intensity": "Average intensity across all rides (Float)",
      "total_capacity": "Total capacity across all rides (Integer)",
      "ride_list": [
         {
         "subtype": "Type of ride: 'roller_coaster', 'ferris_wheel', or 'carousel' (String)",
         "subclass": "Class of ride: 'yellow', 'blue', 'green', or 'red' (String)",
         "x": f"X coordinate of the ride on the grid (Integer, 0 to {PARK_SIZE-1})",
         "y": f"Y coordinate of the ride on the grid (Integer, 0 to {PARK_SIZE-1})",
         "out_of_service": "Whether the ride is out of service (Boolean)",
         "uptime": "Proportion of the day that this ride is not out of service (Float, 0.0 to 1.0)",
         "cleanliness": "Cleanliness level of the ride (Float, 0.0 to 1.0)",
         "ticket_price": "Current ticket price for the ride (Integer)",
         "operating_cost": "Operating cost incurred over the day (Integer)",
         "revenue_generated": "Revenue generated by this ride (Integer)",
         "capacity": "Number of guests the ride can hold per operation (Integer)",
         "intensity": "Intensity level of the ride (Integer, 1 to 10)",
         "excitement": "Excitement level provided by the ride (Integer, 1 to 10)",
         "guests_entertained": "Number of guests entertained by this ride (Integer)",
         "times_operated": "Number of times this ride has operated (Integer)",
         "cost_per_operation": "Cost to operate the ride once (Integer)",
         "avg_wait_time": "Average wait time for this ride (Float)",
         "avg_guests_per_operation": "Average number of guests per operation (Float)",
         "breakdown_rate": "The probability of the ride breaking down per operation (Float, 0.0 to 1.0)",
         }
      ]
   },
   "shops": {
      "total_shops": "The total number of shops in the park (Integer)",
      "min_uptime": "Minimum uptime across all shops (Float, 0.0 to 1.0)",
      "total_revenue_generated": "Sum of revenue generated for all shops (Integer)",
      "total_operating_cost": "Sum of operating costs for all shops (Integer)",
      "shop_list":  [
         {
         "subtype": "Type of shop: 'food', 'drink', or 'specialty' (String)",
         "subclass": "Class of shop: 'yellow', 'blue', 'green', or 'red' (String)",
         "x": f"X coordinate of the shop on the grid (Integer, 0 to {PARK_SIZE-1})",
         "y": f"Y coordinate of the shop on the grid (Integer, 0 to {PARK_SIZE-1})",
         "item_price": "Price at which customers buy the items sold in the shop (Integer)",
         "item_cost": "Cost to the park of purchasing the items sold in the shop (Integer)",
         "operating_cost": "Operating cost per day (Integer)",
         "number_of_restocks": "Number of times the shop was restocked this day (Integer)",
         "order_quantity": "Quantity of inventory purchased at the start of each day (Integer)",
         "inventory": "Unsold inventory (Integer)",
         "revenue_generated": "Revenue generated by this shop (Integer)",
         "cleanliness": "Cleanliness level of the shop (Float, 0.0 to 1.0)",
         "guests_served": "Number of guests served by this shop (Integer)",
         "out_of_service": "Whether the shop is out of service, i.e. has zero inventory (Boolean)",
         "uptime": "Proportion of time this shop was not out of service (Float, 0.0 to 1.0)",
         }
      ]
   },
   "staff": {
      "total_janitors": "Total number of janitors employed; grouped by yellow, blue, green, or red  (List of Integers)",
      "total_mechanics": "Total number of mechanics employed; grouped by yellow, blue, green, or red (List of Integers)",
      "total_specialists": "Total number of specialists employed; grouped by yellow, blue, green, or red (List of Integers)",
      "total_salary_paid": "Total salary paid to all staff (Integer)",
      "total_operating_cost": "Total operating costs for all staff (Integer)",
      "staff_list": [
         {
         "subtype": "Type of employee: 'janitor', 'mechanic', or 'specialist', (String)",
         "subclass": "Class of employee: 'yellow', 'blue', 'green', or 'red' (String)",
         "x": f"X coordinate of the employee on the grid (Integer, 0 to {PARK_SIZE-1})",
         "y": f"Y coordinate of the employee on the grid (Integer, 0 to {PARK_SIZE-1})",
         "salary": "The daily salary of this employee (Integer)",
         "tiles_traversed": "The number of tiles traversed by this employee (Integer)",
         "operating_cost": "The non-salary costs incurred by this employee performing their job (Integer)",
         "success_metric_value": "Measure of the employee's success. E.g., Number of tiles cleaned by a janitor, number of repair steps for a mechanic, number of restocks for a stocker, guests entertained for a clown, guests informed for the crier, and guests served for the vendor  (Float)",
         "success_metric": "A description of this employee's success metric. 'amount_cleaned' for janitors, 'repair_steps_performed' for mechanics, 'guests_entertained' for clowns, 'restocks_performed' for stockers, 'guests_informed' for criers and 'guests_served' for vendors (String)",
         }
      ],
   },
   "paths": [
      {
         "x": f"X coordinate of the path on the grid (Integer, 0 to {PARK_SIZE-1})",
         "y": f"Y coordinate of the path on the grid (Integer, 0 to {PARK_SIZE-1})",
         "cleanliness": "Cleanliness level of the path (Float, 0.0 to 1.0)"
      }
   ],
   "waters": [
      {
         "x": f"X coordinate of the water tile on the grid (Integer, 0 to {PARK_SIZE-1})",
         "y": f"Y coordinate of the water tile on the grid (Integer, 0 to {PARK_SIZE-1})"
      }
   ]  
}

DETAILED_GUEST_STATE_SPEC = copy.deepcopy(STATE_SPEC_DICT)
DETAILED_GUEST_STATE_SPEC["guest_survey_results"]  = {
       "age_of_results" : "The number of steps between the last time you ran the survey and the current step. (Integer)",
       "list_of_results" : [
           {
             "happiness_at_exit": "The happiness level of the guests at exit. (Float)",
             "hunger_at_exit": "The hunger of the guests at exit. (Float)",
             "thirst_at_exit": "The thirst of the guests at exit. (Float)",
             "remaining_energy" : "The amount of energy the guest had when they left the park. (Float)",
             "remaining_money": "The amount of money the guest had when they left the park. (Float)",
             "percent_of_money_spent" : "The percentage of the total amount of money that the guest has spent in the park. (Float)",
             "reason_for_exit" : "A string representing why the guest has left the park. (String)",
             "preference" : "A string representing any ride preferences of the guest. Standard means there are no particular preferences (String)"
           }
       ]
}